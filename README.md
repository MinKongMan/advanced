# 로그 추적기
```
애플리케이션 개발 후 시간이 지나면 모니터링과 운영이 중요해지는 단계가 옴(여기서 이 단계를 수행할 예정)
최근에 병목현상 발생 -> 장애가 생김
어떤 부분에서 병목이, 에러가 생기는지 로그를 통해 문제를 해결하려고 함
```

# 요구사항



# 베타 버전
### V0
  - 기본적인 클래스 생성 및 기능 구현

### V1
  - Controller, Service, Repository에 구현한 기능 적용
  - 하나의 작업에 대해 아직 traceId가 일치하지 않음

### V2
  - V1에서 traceId가 일치하지 않는 오류 해결
  > Controller에서 traceId를 생성하고 인자를 넘겨주는 방식으로 구현</br>
  > 만약 Service로 바로 실행되는 작업에 대해 오류가 발생함

# 정식 버전
  - FiledLogTrace 인터페이스 생성 (모든 작업을 포함)
  - 위 인터페이스를 구현하고 인자를 넘겨주는 작업 대신 전역 변수로 traceIdHolder 생성(아직 동시성 이슈 발생)
  
### V3
  - logTrace 스프링 빈 등록 
  - traceId를 인자로 넘겨주던 작업 모두 제거 
  - Hellotrace2에서 이전에 구현했던 logTrace으로 변경

# 동시성 문제 발생
  ```
  1초에 2번 연속 실행했을 때 
  서로 다른 쓰레드가 같은 traceId를 가지게 됨
  ```
 - FieldlogTrace가 싱글톤으로 등록되어 인스턴스가 1개만 생성되는데 비해</br>
  여러 스레드가 동시에 접근해서 발생하는 문제

  ```
  TreadLocal
  쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소
  ```

 ### 일반적인 변수 필드
 - 여러 쓰레드가 같은 인스턴스의 필드에 접근하면 처음 쓰레드가 보관한 데이터가 사라질 수 있다.
  > 싱글톤 인스턴스에 쓰레드A가 저장하고 바로 다음에 쓰레드B가 같은 인스턴스에 저장하면 쓰레드A가 저장한 값이 사라짐
   
 ### 쓰레드 로컬
 - 각 쓰레드마다 별도의 내부 저장소를 제공한다. 따라서 같은 인스턴스의 쓰레드의 로컬 필드에 접근해도 문제X
  > 쓰레드A가 쓰레드 로컬(객체)에 값을 담으면 쓰레드 로컬은 저장된 값을 쓰레드A 전용 보관소에 데이터를 저장(안전)<br/>
  > 이후 각 쓰레드별로 쓰레드 로컬에 값을 조회하는 요청을 보내면 쓰레드 로컬은 그에 맞는 저장소에서 값을 꺼내 리턴함
  
 - 사용한 후에는 반드시 ThreadLocal.remove()를 통해 쓰레드 로컬에 저장된 값을 제거해야함(메모리 누수 발생)
 - 사용 후 제거하지 않으면 WAS처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있음
 1. 사용자A가 HTTP 요청을 통해 저장을 하고자 한다</br>
 2. WAS는 쓰레드 풀에서 요청을 처리하기 위해 쓰레드를 꺼냄</br>
 3. 쓰레드 A가 꺼내져 쓰레드 로컬에 데이터를 저장(쓰레드 전용 보관소에 저장)</br>
 4. 저장 요청 종료 후 WAS는 사용이 끝난 쓰레드A를 쓰레드 풀에 반환</br>
 5. 이때 쓰레드A가 죽지 않고 재사용 되기 위해 살아있기 때문에 이에 대한 쓰레드 로컬도 살아있음</br>
 6. 그 후 다른 사용자가 쓰레드A를 사용하여 데이터를 조회할 때 기존에 있던 쓰레드 로컬의 데이터를 참조한다.</br>
 7. 이런 문제를 예방하기 위해 반드시 쓰레드 로컬을 제거해줘야 한다.